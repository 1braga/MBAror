1. Variables, conditionals and debugging techniques

sigils = $ @ @@

Scope: Local, instance, global, class

class Person
    def initialize(name)
    @name = name
    end

    def greet
        puts "Hello, my name is #{@name}"
    end
end

p = Person.new("Giovanna")
p.greet

---------------------------------------------------

class Calculator
    @@count = 0 #variavel disponivel na classe

    def initialize
        @@count += 1
    end

    def self.count
        puts "Value: #{@@count}"
    end
end

Calculator.new #inicia com 0 e soma com 1 a cada vez chamada
Calculator.count

---------------------------------------------------
shadowing
---------------------------------------------------
class Counter
    def initialize
        @count = 0
    end

    def increase
        count = 10
        @count += 1
        count += 1
        puts "Inside method: count = #{count}, @count = #{count}"
    end

    def show_count
        puts "Instance variable count: #{count}"
    end
end

counter = Counter.new
counter.increase
counter.show_count
puts "Trying to acess local variable: #{counter.count}" #Will it work?
---------------------------------------------------
class Animal
    @@total_animals = 0

    def initialize(name)
        @name = name
        @@total_animals += 1
    end

    def show_name
        puts "Animal's name: #{@name}"
    end

    def self.total_animals
        puts "Total animals created: #{@@total_animals}"
    end

    dog = Animal.new("Buddy")
    cat = Animal.new("Whiskers")

    dog.show_name
    cat.show_name

    Animal.total_animals
    puts dog.total_animals #Will this line work? Why or why not?
---------------------------------------------------
estrutura de decisão: Cyclomatic complexity
- medir a complexidade do código de acordo com a quantidade de decisões que a aplicação tem que fazer
---------------------------------------------------
def sum_if_odd(x, y)
    if x.odd? && y.odd?
        puts "Both are odd"
        return x + y
    elseif x.odd? && y.even?
        puts "y is even adn x is odd"
    else
        puts "Nothing happened"
    end
end

sum_if_odd(2, 2)
---------------------------------------------------
outra versão do código de cima:
def sum_if_odd(x, y)
    return x+y if x.odd? && y.odd? #early return
    return x-y if x.even? && y.even? #guard clause

    puts "Nothing happened"
end

sum_if_odd(2, 2)
---------------------------------------------------
